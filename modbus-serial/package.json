{
  "name": "modbus-serial",
  "version": "4.0.3",
  "description": "A pure JavaScript implemetation of MODBUS-RTU (and TCP) for NodeJS.",
  "main": "index.js",
  "scripts": {
    "test": "mocha --recursive"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/yaacov/node-modbus-serial.git"
  },
  "keywords": [
    "modbus",
    "rtu",
    "serial",
    "port",
    "com",
    "arduino"
  ],
  "author": {
    "name": "Yaacov Zamir",
    "email": "kobi.zamir@gmail.com"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/yaacov/node-modbus-serial/issues"
  },
  "homepage": "https://github.com/yaacov/node-modbus-serial#readme",
  "devDependencies": {
    "chai": "^3.4.0",
    "mocha": "^2.3.3",
    "mockery": "^1.4.0"
  },
  "readme": "# modbus-serial\nA pure JavaScript implemetation of MODBUS-RTU (and TCP) for NodeJS\n\n[![npm](https://img.shields.io/npm/v/npm.svg)](https://www.npmjs.com/package/modbus-serial)\n\nThis class makes ModbusRTU (and TCP) calls fun and easy.\n\nModbus is a serial communications protocol, first used in 1979.\nModbus is simple and robust, openly published, royalty-free and\neasy to deploy and maintain.\n\n----\n\n- [Install](#install)\n- [What can I do with this module ?](#what-can-i-do-with-this-module-)\n- [Compatibility](#compatibility)\n- [Examples](#examples)\n- [Methods](#methods)\n      - [API Promises](#api-promises)\n      - [API Callbacks](#api-callbacks)\n      - [API connection shorthand](#api-connection-shorthand)\n\n----\n\n#### Install\n\n```\nnpm install modbus-serial\n```\n\nFor use over serial port (ModbusRTU), also install node-serialport:\n```\nnpm install serialport\n```\n\n#### What can I do with this module ?\n\nThis class makes it fun and easy to communicate with electronic\ndevices such as irrigation controllers, protocol droids and robots.\nIt talks with devices that use a serial line (e.g. RS485, RS232).\nMany industrial electronic devices implement modbus.\nArduino can also talk modbus and you can control your projects and robots\nusing modbus.\n\nArduino libraries for modbus slave:\n* https://github.com/yaacov/arduino-modbus-slave\n* https://github.com/smarmengol/Modbus-Master-Slave-for-Arduino\n\nArduino sketch for irrigation timer with modbus support:\n* https://github.com/yaacov/arduino-irrigation-timer\n\nNode Modbus-WebSocket bridge:\n* https://github.com/yaacov/node-modbus-ws\n\n#### Compatibility\n\n###### This class implements:\n\n* FC1 \"Read Coil Status\"\n* FC2 \"Read Input Status\"\n* FC3 \"Read Holding Registers\"\n* FC4 \"Read Input Registers\"\n* FC5 \"Force Single Coil\"\n* FC6 \"Preset Single Register\"\n* FC15 \"Force Multiple Coil\"\n* FC16 \"Preset Multiple Registers\"\n\n###### Connects types:\n\n* modbus-RTU (modbus-rtu): Over serial line [require node serialport].\n* modbus-ASCII (modbus-ascii): Over serial line [require node serialport].\n* modbus-TCP (modbus-tcp): Over TCP/IP line.\n* modbus-RTU (telnet): Over Telnet server, TCP/IP serial bridge.\n* modbus-RTU (buffered): Over buffered serial line [require node serialport].\n* modbus-RTU (C701): Over C701 server, commercial UDP to serial bridge.\n\n#### Examples\n----\n###### Logger\n``` javascript\n// create an empty modbus client\nvar ModbusRTU = require(\"modbus-serial\");\nvar client = new ModbusRTU();\n\n// open connection to a tcp line\nclient.connectTCP(\"192.168.1.42\", run);\n\n// read the values of 10 registers starting at address 0\n// on device number 1. and log the values to the console.\nfunction run() {\n    client.setID(1);\n\n    client.readInputRegisters(0, 10)\n        .then(console.log)\n        .then(run);\n}\n```\n\n----\n###### Read and Write\n``` javascript\n// create an empty modbus client\nvar ModbusRTU = require(\"modbus-serial\");\nvar client = new ModbusRTU();\n\n// open connection to a serial port\nclient.connectRTU(\"/dev/ttyUSB0\", {baudrate: 9600}, write);\n\nfunction write() {\n    client.setID(1);\n\n    // write the values 0, 0xffff to registers starting at address 5\n    // on device number 1.\n    client.writeRegisters(5, [0 , 0xffff])\n        .then(read);\n}\n\nfunction read() {\n    // read the 2 registers starting at address 5\n    // on device number 1.\n    client.readHoldingRegisters(5, 2)\n        .then(console.log);\n}\n```\n----\n###### Logger\n``` javascript\n// create an empty modbus client\nvar ModbusRTU = require(\"modbus-serial\");\nvar client = new ModbusRTU();\n\n// open connection to a serial port\nclient.connectRTU(\"/dev/ttyUSB0\", {baudrate: 9600});\nclient.setID(1);\n\n// read the values of 10 registers starting at address 0\n// on device number 1. and log the values to the console.\nsetInterval(function() {\n    client.readHoldingRegisters(0, 10, function(err, data) {\n        console.log(data.data);\n    });\n}, 1000);\n```\n----\n###### Logger-TCP\n``` javascript\n// create an empty modbus client\nvar ModbusRTU = require(\"modbus-serial\");\nvar client = new ModbusRTU();\n\n// open connection to a tcp line\nclient.connectTCP(\"192.168.1.42\");\nclient.setID(1);\n\n// read the values of 10 registers starting at address 0\n// on device number 1. and log the values to the console.\nsetInterval(function() {\n    client.readHoldingRegisters(0, 10, function(err, data) {\n        console.log(data.data);\n    });\n}, 1000);\n```\n----\n###### Read raw buffer\n``` javascript\n// create an empty modbus client\nvar ModbusRTU = require(\"modbus-serial\");\nvar client = new ModbusRTU();\n\n// open connection to a serial port\nclient.connectRTU(\"/dev/ttyUSB0\", {baudrate: 9600}, run);\n\nfunction run() {\n    client.setID(1);\n\n    // read 2 16bit-registers to get one 32bit number\n    client.readInputRegisters(5, 2, function(err, data) {\n        var int32 = data.buffer.readUInt32BE();\n        console.log(int32);\n    });\n}\n```\n\n#### Methods\n\n----\n###### API promises\n----\n\nThis communication functions use a pre-set unit-id and can return a promise,\nUsing callbacks is optional.\n\n```javascript\n// set the client's unit id\nclient.setID(1);\n\n// read 8 discrete inputs starting at input 10\n// (function use the unit id 1, we set earlier)\nclient.readDiscreteInputs(10, 8)\n    .then(function(data) {\n        console.log(data);\n    });\n```\n\n----\n##### .setID(id)\n      Sets the unit id\n\n*id {number}:*\nThe new client id\n\n----\n##### .readCoils (address, length)\n      Writes \"Read Coils\" (FC=1) request to serial port.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*length {number}:*\nThe total number of registers requested.\n\n----\n##### .readDiscreteInputs (address, length)\n      Writes \"Read Discrete Inputs\" (FC=2) request to serial port.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*length {number}:*\nThe total number of registers requested.\n\n----\n##### .readHoldingRegisters (address, length)\n      Writes \"Read Holding Registers\" (FC=3) request to serial port.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*length {number}:*\nThe total number of registers requested.\n\n----\n##### .readInputRegisters (address, length)\n      Writes \"Read Input Registers\" (FC=4) request to serial port.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*length {number}:*\nThe total number of registers requested.\n\n----\n##### .writeCoil(address, state)\n      Writes \"Force Coil Status\" (FC=5) request to serial port.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*state {boolean}:*\nThe state to force into coil.\n\n----\n##### .writeCoils(address, array)\n      Writes \"Force Multiple Coils\" (FC=15) request to serial port.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*array {array}:*\nThe array of states to force into the coils.\n\n----\n##### .writeRegisters (address, array)\n      Writes \"Preset Multiple Registers\" (FC=16) request to serial port.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*array {array}:*\nThe array of values to set into the registers.\n\n----\n\n----\n##### .writeRegister (address, value)\n      Writes \"Preset Single Register\" (FC=6) request to serial port.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*value {number}:*\nThe value to set into the register.\n\n----\n###### API Callbacks\n----\n\nThis communication functions use callbacks.\n\n```javascript\n\n// read 8 holding registers starting at register 10\n// (function use the unit id 1)\nclient.writeFC3(1, 10, 8, function(err, data) {\n      if (err) {\n            console.log(err);\n      } else {\n            console.log(data);\n      });\n```\n\n----\n##### .open(callback)\n      Opens a modbus connection using the given serial port.\n\n*callback {function}:* (optional)\nCalled when a connection has been opened.\n\n----\n##### .writeFC1 (unit, address, length, callback)\n      Writes \"Read coil status\" (FC=01) request to serial port.\n\n*unit {number}:*\nThe slave unit address.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*length {number}:*\nThe total number of registers requested.\n\n*callback {function}:* (optional)\nCalled once the unit returns an answer. The callback should be a function\nthat looks like: function (error, data) { ... }\n```\nerror - null on success, error string o/w\ndata - an object with two fildes:\n    data.data: array of boolean coils (in multiples of 8 = one byte).\n    data.buffer: raw baffer of bytes returned by slave.\n```\n\n----\n##### .writeFC2 (unit, address, length, callback)\n      Writes \"Read input status\" (FC=02) request to serial port.\n\n*unit {number}:*\nThe slave unit address.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*length {number}:*\nThe total number of registers requested.\n\n*callback {function}:* (optional)\nCalled once the unit returns an answer. The callback should be a function\nthat looks like: function (error, data) { ... }\n```\nerror - null on success, error string o/w\ndata - an object with two fildes:\n    data.data: array of boolean digital inputs (in multiples of 8 = one byte).\n    data.buffer: raw baffer of bytes returned by slave.\n```\n\n----\n##### .writeFC3 (unit, address, length, callback)\n      Writes \"Read Holding Registers\" (FC=03) request to serial port.\n\n*unit {number}:*\nThe slave unit address.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*length {number}:*\nThe total number of registers requested.\n\n*callback {function}:* (optional)\nCalled once the unit returns an answer. The callback should be a function\nthat looks like: function (error, data) { ... }\n```\nerror - null on success, error string o/w\ndata - an object with two fildes:\n    data.data: array of unsinged 16 bit registers.\n    data.buffer: raw baffer of bytes returned by slave.\n```\n\n----\n##### .writeFC4 (unit, address, length, callback)\n      Writes \"Read Input Registers\" (FC=04) request to serial port.\n\n*unit {number}:*\nThe slave unit address.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*length {number}:*\nThe total number of registers requested.\n\n*callback {function}:* (optional)\nCalled once the unit returns an answer. The callback should be a function\nthat looks like: function (error, data) { ... }\n```\nerror - null on success, error string o/w\ndata - an object with two fildes:\n    data.data: array of unsinged 16 bit registers.\n    data.buffer: raw baffer of bytes returned by slave.\n```\n\n----\n##### .writeFC5 (unit, address, state, callback)\n      Writes \"Force Single Coil\" (FC=05) request to serial port.\n\n*unit {number}:*\nThe slave unit address.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*state {boolean}:*\nThe coil state.\n\n*callback {function}:* (optional)\nCalled once the unit returns an answer. The callback should be a function\nthat looks like: function (error, data) { ... }\n\n----\n##### .writeFC15 (unit, address, array, callback)\n      Writes \"Force Multiple Coils\" (FC=15) request to serial port.\n\n*unit {number}:*\nThe slave unit address.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*array {array}:*\nThe array of states to send to unit.\n\n*callback {function}:* (optional)\nCalled once the unit returns an answer. The callback should be a function\nthat looks like: function (error, data) { ... }\n\n----\n##### .writeFC6 (unit, address, value, callback)\n      Writes \"Preset Single Register\" (FC=6) request to serial port.\n\n*unit {number}:*\nThe slave unit address.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*value {number}:*\nThe value to sent to unit.\n\n*callback {function}:* (optional)\nCalled once the unit returns an answer. The callback should be a function\nthat looks like: function (error, data) { ... }\n\n----\n##### .writeFC16 (unit, address, array, callback)\n      Writes \"Preset Multiple Registers\" (FC=16) request to serial port.\n\n*unit {number}:*\nThe slave unit address.\n\n*address {number}:*\nThe Data Address of the first register.\n\n*array {array}:*\nThe array of values to sent to unit.\n\n*callback {function}:* (optional)\nCalled once the unit returns an answer. The callback should be a function\nthat looks like: function (error, data) { ... }\n\n----\n###### API connection shorthand\n----\n\nThe shorthand connection functions creates a port and open it.\n\nLong way, without shorthand:\n``` javascript\n// open a serial port\nvar SerialPort = require(\"serialport\").SerialPort;\nvar serialPort = new SerialPort(\"/dev/ttyUSB0\", {baudrate: 9600});\n\n// create a modbus client using the serial port\nvar ModbusRTU = require(\"modbus-serial\");\nvar client = new ModbusRTU(serialPort);\n\n// open connection to a serial port\nclient.open();\n\n// tell your coffee machine to do something ...\n```\n\nUsing shorthand:\n``` javascript\n// create an empty modbus client\nvar ModbusRTU = require(\"modbus-serial\");\nvar client = new ModbusRTU();\n\n// open connection to a serial port\nclient.connectRTU(\"/dev/ttyUSB0\", {baudrate: 9600});\n\n// tell your robot to do something ...\n```\n\nUsing shorthand (TCP):\n``` javascript\n// create an empty modbus client\nvar ModbusRTU = require(\"modbus-serial\");\nvar client = new ModbusRTU();\n\n// open connection to a tcp line\nclient.connectTCP(\"192.168.1.42\");\n\n// tell your robot to do something ...\n```\n----\n##### .connectRTU (path, options, callback)\n      Connect using serial port.\n\n*path {string}:*\nThe port path (e.g. \"/dev/ttyS0\")\n\n*options {object}:* (optional)\nThe options for this connection.\n\n*callback {function}:* (optional)\nCalled once the client is connected.\n\n----\n##### .connectRTUBuffered (path, options, callback)\n      Connect using buffered serial port.\n      Use when serial port has long delays inside packets.\n\n*path {string}:*\nThe port path (e.g. \"/dev/ttyS0\")\n\n*options {object}:* (optional)\nThe options for this connection.\n\n*callback {function}:* (optional)\nCalled once the client is connected.\n\n----\n##### .connectTCP (ip, options, callback)\n      Connect using tcp/ip.\n\n*ip {string}:*\nThe port ip (e.g. \"24.230.1.42\")\n\n*options {object}:* (optional)\nThe options for this connection.\n\n*callback {function}:* (optional)\nCalled once the client is connected.\n\n----\n##### .connectTelnet (ip, options, callback)\n      Connect using a telnet server\n\n*ip {string}:*\nThe port ip (e.g. \"24.230.1.42\")\n\n*options {object}:* (optional)\nThe options for this connection.\n\n*callback {function}:* (optional)\nCalled once the client is connected.\n\n----\n##### .connectAsciiSerial (path, options, callback)\n      Connect using serial port with ASCII encoding.\n\n*path {string}:*\nThe port path (e.g. \"/dev/ttyS0\")\n\n*options {object}:* (optional)\nThe options for this connection.\n\n*callback {function}:* (optional)\nCalled once the client is connected.\n",
  "readmeFilename": "README.md",
  "_id": "modbus-serial@4.0.3",
  "dist": {
    "shasum": "cf2140da7d8724d511a8241ab9b59bb84d1a68b2"
  },
  "_from": "modbus-serial@",
  "_resolved": "https://registry.npmjs.org/modbus-serial/-/modbus-serial-4.0.3.tgz"
}
